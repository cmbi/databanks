#!/usr/bin/make -f
#
# revised update script using the perl flatten-and-cleanup script for rsync

STARTPATH    := $(shell pwd)

include gmsl

# pdbdiv is used for determining divided paths, example: '1crn' => 'cr'
pdbdiv=$(call substr,$1,2,3)

# first target, will be used by gmake when no other target is provided
firstTarget: all

# Where we locate everything:
DATADIR     = /srv/data/
BINDIR      = /srv/data/bin/
FASTADIR    = $(DATADIR)fasta/
STATSDIR    = $(DATADIR)status/
FLAGSDIR    = $(DATADIR)flags/
WHYNOTDIR   = $(DATADIR)scratch/whynot2/

PATHS        = $(STATSDIR) $(FLAGSDIR) $(FASTADIR)
PATHS        += $(DATABANK:%=$(DATADIR)/%)

# some executables we use
RUN_MAKE        ?= /usr/local/bin/mrs-run-and-log
MRS_BUILD        ?= /usr/local/bin/mrs-build
PDBREDOSCRIPT    ?= /srv/data/zata/pdb_redo.csh
MKDSSP            ?= /usr/local/bin/mkdssp
MKHSSP            ?= /usr/local/bin/mkhssp
CVHSSP            ?= /usr/local/bin/hsspconv
PERL            ?= /usr/bin/perl
SCENES            ?= /usr/local/bin/scenes

# A generic rule to fetch the PDBIDS
PDBIDS        = $(notdir $(wildcard $(DATADIR)pdb/all/pdb*.ent.gz))
PDBIDS        := $(PDBIDS:pdb%.ent.gz=%)

# A generic rule to fetch the MMCIFIDS
MMCIFIDS    = $(notdir $(wildcard $(DATADIR)mmCIF/*.cif.gz))
MMCIFIDS    := $(MMCIFIDS:%.cif.gz=%)

STRUCTIDS    = $(PDBIDS) $(filter-out $(PDBIDS), $(MMCIFIDS))

pickstructfile = $(shell if [ -f /srv/data/pdb/all/pdb$(1).ent.gz ] ; then echo /srv/data/pdb/all/pdb$(1).ent.gz; else echo /srv/data/mmCIF/$(1).cif.gz; fi  )

# some default options
RSYNC_OPTIONS.$(DATABANK)    = -rtv --delete
RSYNC_DEST.$(DATABANK)        = $(DATADIR)$(DATABANK)/
WGET_DEST.$(DATABANK)        = $(DATADIR)$(DATABANK)/
WGET_OPTIONS.$(DATABANK)    = -N -r -nd
WHY_NOT_DIR.$(DATABANK)        = $(DATADIR)$(DATABANK)/
OBSOLETEDIR.$(DATABANK)        = $(DATADIR)$(DATABANK)/obsolete/

# The databanks 
DATABANKS += genbank
RSYNC_URL.genbank = rsync://ftp.ncbi.nih.gov/genbank/
RSYNC_OPTIONS.genbank = -rtv --delete --include='*.seq.gz' --exclude='*'

DATABANKS += gene
RSYNC_URL.gene = rsync://ftp.ncbi.nlm.nih.gov/gene/DATA/ASN_BINARY/All_Data.ags.gz

DATABANKS += go
WGET_SOURCE.go = ftp://ftp.geneontology.org/pub/go/ontology/gene_ontology.obo

DATABANKS += embl
RSYNC_URL.embl = rsync://ftp.ebi.ac.uk/pub/databases/embl/release/
RSYNC_OPTIONS.embl = -aLv --delete --include='*/' --include='*.dat.gz' --exclude='*'

DATABANKS += interpro
WGET_SOURCE.interpro = ftp://ftp.ebi.ac.uk/pub/databases/interpro/current/interpro.xml.gz

DATABANKS += mimmap
WGET_SOURCE.mimmap = ftp://ftp.ncbi.nih.gov/repository/OMIM/ARCHIVE/genemap

DATABANKS += omim
WGET_SOURCE.omim = ftp://ftp.ncbi.nih.gov/repository/OMIM/ARCHIVE/omim.txt.Z

DATABANKS += oxford
WGET_SOURCE.oxford = ftp://ftp.informatics.jax.org/pub/reports/HMD_HumanPhenotype.rpt

DATABANKS += pfam
RSYNC_URL.pfam = rsync://ftp.ebi.ac.uk/pub/databases/Pfam/current_release/
RSYNC_OPTIONS.pfam = -rtv --delete --include='Pfam-A.full.gz' --include='Pfam-A.seed.gz' --exclude='*'

DATABANKS += pmc
RSYNC_URL.pmc = rsync://ftp.ncbi.nih.gov/pub/pmc/
RSYNC_OPTIONS.pmc = -rtv --delete --include='articles*.tar.gz' --exclude='*'

DATABANKS += prints
RSYNC_URL.prints = rsync://ftp.ebi.ac.uk/pub/databases/prints/
RSYNC_OPTIONS.prints = -rtv --delete --include='*.dat.gz' --exclude='*'

DATABANKS += prosite
RSYNC_URL.prosite = rsync://ftp.ebi.ac.uk/pub/databases/prosite/
RSYNC_OPTIONS.prosite = -rtv --delete --include='prosite*.dat' --include='prosite*.doc' --exclude='*'

DATABANKS += rebase
WGET_SOURCE.rebase = ftp://ftp.neb.com/pub/rebase/bairoch.txt

DATABANKS += refseq
RSYNC_URL.refseq = rsync://ftp.ncbi.nih.gov/refseq/release/complete/
RSYNC_OPTIONS.refseq = -rtv --delete --include='*g{p,b}ff.gz' --exclude='*'

DATABANKS += taxonomy
WGET_SOURCE.taxonomy = ftp://ftp.ebi.ac.uk/pub/databases/taxonomy/taxonomy.dat

DATABANKS += unigene
RSYNC_URL.unigene = rsync://ftp.ebi.ac.uk/pub/databases/Unigene/
RSYNC_OPTIONS.unigene = -rtv --delete --include='*/' --include='*.data.gz' --exclude='*'

DATABANKS                        += enzyme
RSYNC_URL.enzyme                = rsync://ftp.ebi.ac.uk/pub/databases/enzyme/release_with_updates/

DATABANKS                       += nmr_restraints
RSYNC_URL.nmr_restraints	    = rsync.wwpdb.org::ftp_data/structures/divided/nmr_restraints/**/
RSYNC_OPTIONS.nmr_restraints	= -rtv --delete --port=33444 --include='????.mr.gz' --exclude='*'
RSYNC_DEST.nmr_restraints	   = $(DATADIR)nmr_restraints/
DELETE.nmr_restraints	        = $(FRAUDULENTIDS:%=$(DATADIR)nmr_restraints/%.mr.gz)
WHY_NOT_DB.nmr_restraints	   = NMR
WHY_NOT_DIR.nmr_restraints	  = $(DATADIR)nmr_restraints/

DATABANKS                        += pdb
RSYNC_URL.pdb                    = rsync.wwpdb.org::ftp_data/structures/divided/pdb/**/
RSYNC_OPTIONS.pdb                = -rtv --delete --port=33444 --include='pdb????.ent.gz' --exclude='*'
RSYNC_DEST.pdb                    = $(DATADIR)pdb/all/
#FLATTEN.pdb                        = pdb
DATFILES.pdb                    = $(PDBIDS:%=$(DATADIR)pdb/flat/pdb%.ent)
#DATFILES.pdb                   = $(foreach ID,$(PDBIDS), $(DATADIR)pdb/text/divided/$(call pdbdiv,$(ID))/pdb$(ID).ent)
DELETE.pdb                        = $(FRAUDULENTIDS:%=$(DATADIR)pdb/all/pdb%.ent.gz) $(FRAUDULENTIDS:%=$(DATADIR)pdb/flat/pdb%.ent)
OBSOLETE.pdb                     = $(filter-out $(DATFILES.pdb), $(wildcard $(DATADIR)pdb/flat/*))
WHY_NOT_DB.pdb                    = PDB
WHY_NOT_DIR.pdb                    := $(DATADIR)pdb/flat/
#WHY_NOT_DIR.pdb                    := $(DATADIR)pdb/text/divided/
MAKE_DATA_FLAGS.pdb                = -j32


RUNAFTER.pdb                    = $(BINDIR)adjustSkipList.bash $(BINDIR)pdbredo_skip.txt

$(DATADIR)pdb/flat/pdb%.ent: $(DATADIR)pdb/all/pdb%.ent.gz
	zcat -c $< > $@
	touch -r $< $@
#$(DATADIR)pdb/text/divided/%.ent: $(DATADIR)pdb/divided/%.ent.gz
#	if ! [ -d $$(dirname $@) ] ; then mkdir -p $$(dirname $@) ; fi
#	zcat -c $< > $@

FRAUDULENTIDS = $(shell cat $(DATADIR)bin/pdb_fraud)
RSYNC_EXCLUDES = $(FRAUDULENTIDS:%=--exclude='*%*')

# pdbechem's rsync is bugged, use wget until it's fixed!
DATABANKS                        += pdbechem
#RSYNC_URL.pdbechem                = ftp.ebi.ac.uk::pub/databases/msd/pdbechem/
WGET_OPTIONS.pdbechem            = -Nr --no-host-directories --cut-dirs=4
WGET_SOURCE.pdbechem            = ftp://ftp.ebi.ac.uk/pub/databases/msd/pdbechem/*

#$(FLAGSDIR)pdbechem.fetch_done:: FORCE
#	$(BINDIR)m6 fetch --verbose --config=$(BINDIR)m6-config.xml pdbechem

DATABANKS            += structure_factors
#FLATTEN.structure_factors	    = structure_factors
RSYNC_URL.structure_factors	 = rsync.wwpdb.org::ftp_data/structures/divided/structure_factors/**/
RSYNC_OPTIONS.structure_factors  = -rtv --delete --port=33444 --include='r????sf.ent.gz' --exclude='*'
RSYNC_DEST.structure_factors	 = $(DATADIR)structure_factors/
WHY_NOT_DB.structure_factors	 = STRUCTUREFACTORS
WHY_NOT_DIR.structure_factors	 := $(DATADIR)structure_factors/
DELETE.structure_factors	 = $(FRAUDULENTIDS:%=$(DATADIR)structure_factors/r%sf.ent.gz)
#WHY_NOT_DIR.structure_factors   := $(DATADIR)rcsb/structure_factors/divided/

SF_FILES    = $(wildcard $(DATADIR)structure_factors/r????sf.ent.gz)
SF_IDS        = $(SF_FILES:$(DATADIR)structure_factors/r%sf.ent.gz=%)

DATABANKS                        += mmCIF
#FLATTEN.mmCIF                    = mmCIF
RSYNC_URL.mmCIF                   = rsync.wwpdb.org::ftp_data/structures/divided/mmCIF/**/
RSYNC_OPTIONS.mmCIF               = -rtv --delete --port=33444 --include='????.cif.gz' --exclude='*'
RSYNC_DEST.mmCIF                  = $(DATADIR)mmCIF/
WHY_NOT_DB.mmCIF                  = MMCIF
DELETE.mmCIF                      = $(FRAUDULENTIDS:%=$(DATADIR)mmCIF/%.cif.gz)

DATABANKS                         += dssp
DSSPIDS                           = $(STRUCTIDS)
DSSPIDSVALID                      = $(filter-out $(shell /bin/cat dssp_skip.txt), $(DSSPIDS))
DATFILES.dssp                     = $(DSSPIDSVALID:%=$(DATADIR)dssp/%.dssp)
DELETE.dssp                       = $(filter-out $(DSSPIDS:%=$(DATADIR)dssp/%.dssp), $(wildcard $(DATADIR)dssp/*.dssp))

#VPATH.dssp                        = pdb%.ent.gz $(DATADIR)pdb/all
WHY_NOT_DB.dssp                    = DSSP
MAKE_DATA_FLAGS.dssp               = -j32 -k

# pdb has priority over mmcif
$(DATADIR)dssp/%.dssp: $(DATADIR)pdb/all/pdb%.ent.gz
	($(MKDSSP) $< $@ 2> /srv/data/scratch/whynot2/dssp/$*.err) || ( echo $* >> dssp_skip.txt; rm -f $@ )
	rm -f $(DATADIR)pdbfinder/data/$*.dat

$(DATADIR)dssp/%.dssp: $(DATADIR)mmCIF/%.cif.gz
	($(MKDSSP) $< $@ 2> /srv/data/scratch/whynot2/dssp/$*.err) || ( echo $* >> dssp_skip.txt; rm -f $@ )
	rm -f $(DATADIR)pdbfinder/data/$*.dat

dssp: pdb


DATABANKS                       += bdb
DATFILES.bdb                    = $(foreach id,$(PDBIDS),$(DATADIR)bdb/$(call pdbdiv,$(id))/$(id)/$(id).bdb)
MAKE_DATA_FLAGS.bdb             = -j32 -k
WHY_NOT_DB.bdb                  = BDB
# When the bdb file is obsolete, the entire directory will be deleted:
DELETE.bdb                      = $(filter-out $(dir $(DATFILES.bdb)), $(wildcard $(DATADIR)bdb/*/*/))


ifeq ($(DATABANK),bdb)
include bdb.depends
endif

bdb.depends:
	find $(DATADIR)pdb/flat/ -name "pdb*.ent" | \
	    sed -e 's|$(DATADIR)pdb/flat/pdb\(.\)\(..\)\(.\)\.ent|$(DATADIR)bdb/\2/\1\2\3/\1\2\3.bdb: \0\n|' \
	    > bdb.depends

# During execution, the bdb script might generate a whynot file. If it's newly created, this whynot file must be annotated.
# Old whynot files must be unannotated if they are not the same.
# The BDBUpdate bash script handles all this for a given pdb id.
$(DATADIR)bdb/%.bdb: /usr/local/bin/mkbdb
	/srv/data/bin/BDBUpdate.bash `basename $(@D)`


DATABANKS                    += hssp3
HSSP3IDS                    = $(filter-out $(shell cat hssp3-skip.txt), $(STRUCTIDS))
HSSP3FILES                    = $(HSSP3IDS:%=$(DATADIR)hssp3/%.hssp.bz2)
#VPATH.hssp3                    = pdb%.ent.gz $(DATADIR)pdb/all/
DATFILES.hssp3                    = $(HSSP3IDS:%=$(DATADIR)hssp3/%.hssp.bz2)
DELETE.hssp3                    += $(filter-out $(STRUCTIDS:%=$(DATADIR)hssp3/%.hssp.bz2), $(wildcard $(DATADIR)hssp3/*))
SORTED_HSSP3                    = $(shell ls -rt $(DATADIR)hssp3/)
DATFILES.hssp3                    += $(OUTDATED_HSSP3)
MAKE_DATA_FLAGS.hssp3            = -j32 -k

hssp3: pdb uniprot

$(OUTDATED_HSSP3): /srv/data/fasta/uniprot_sprot.fasta

# UPDATEHSSP can be set on command line, in combination with a single requested file
ifeq ($(UPDATEHSSP),true)
$(HSSP3FILES): /srv/data/fasta/uniprot_sprot.fasta
endif

# pdb has priority over mmcif
$(DATADIR)hssp3/%.hssp.bz2: /srv/data/pdb/all/pdb%.ent.gz
	( $(MKHSSP) -o $@ -a 1 -m 2500 --fetch-dbrefs $< -d /srv/data/fasta/uniprot_sprot.fasta -d /srv/data/fasta/uniprot_trembl.fasta \
	    2> /srv/data/scratch/whynot2/hssp/$*.err ) || (echo $* >> hssp3-skip.txt ; rm -f $@)

$(DATADIR)hssp3/%.hssp.bz2: /srv/data/mmCIF/%.cif.gz
	( $(MKHSSP) -o $@ -a 1 -m 2500 --fetch-dbrefs $< -d /srv/data/fasta/uniprot_sprot.fasta -d /srv/data/fasta/uniprot_trembl.fasta \
	            2> /srv/data/scratch/whynot2/hssp/$*.err ) || (echo $* >> hssp3-skip.txt ; rm -f $@)

DATABANKS                        += hssp
PRESENTHSSP3FILES                = $(wildcard $(DATADIR)hssp3/*.hssp.bz2)
HSSPIDS                          = $(PRESENTHSSP3FILES:$(DATADIR)hssp3/%.hssp.bz2=%)
#HSSPIDS                          = $(filter-out $(shell cat hssp1-fail.txt), $(HSSP3IDS))
DATFILES.hssp                    = $(HSSPIDS:%=$(DATADIR)hssp/%.hssp.bz2)
DELETE.hssp                      = $(filter-out $(HSSPIDS:%=$(DATADIR)hssp/%.hssp.bz2), $(wildcard $(DATADIR)hssp/*))
WHY_NOT_DB.hssp                  = HSSP
MAKE_DATA_FLAGS.hssp             = -j32 -k

hssp: hssp3

$(DATADIR)hssp/%.hssp.bz2: $(DATADIR)hssp3/%.hssp.bz2
	$(CVHSSP) $< $@ || (echo $* >> hssp1-fail.txt ; rm -f $@)
	rm -f $(DATADIR)pdbfinder/data/$*.dat

DATABANKS                        += pdbfinder
PDBFINDERIDS                    = $(PDBIDS)
DATFILES.pdbfinder                = $(DATADIR)pdbfinder/PDBFIND.TXT
DATFILES2.pdbfinder                = $(PDBFINDERIDS:%=$(DATADIR)pdbfinder/data/%.dat)
DELETE.pdbfinder                = $(filter-out $(DATFILES2.pdbfinder), $(wildcard $(DATADIR)pdbfinder/data/*.dat))
WHY_NOT_DIR.pdbfinder            = $(DATADIR)$(DATABANK)/PDBFIND.TXT
WHY_NOT_DB.pdbfinder            = PDBFINDER
PATHS                            += $(DATADIR)/pdbfinder/data/
MAKE_DATA_FLAGS.pdbfinder        += -j32

pdbfinder: structure_factors hssp dssp 

$(DATADIR)pdbfinder/data/%.dat: $(DATADIR)mmCIF/%.cif.gz
	echo $(@F:%.dat=%) | /srv/data/prog/pdbfinder/mkpdbfinder -H > $@ 

$(DATADIR)pdbfinder/PDBFIND.TXT: $(DATFILES2.pdbfinder)
	if [ "x$(DELETE.pdbfinder)" != "x" ] ; then rm -f $(DELETE.pdbfinder); fi
	/srv/data/prog/pdbfinder/mkpdbfinder -A $(DATADIR)pdbfinder/data/ > $@
	gzip -c $@ > $@.gz

DATABANKS                        += pdbfinder2
DATFILES.pdbfinder2                = $(DATADIR)pdbfinder2/PDBFIND2.TXT
#CHECKDBFILES                    = $(shell find /srv/data/pdbreport/checkdb/ -name *.cdb.gz)
#CHECKDBIDS                    = $(CHECKDBFILES:/srv/data/pdbreport/checkdb/%.cdb.gz=%)
PDBFINDER2IDS                    = $(filter-out $(shell cat $(STATSDIR)pdbfinder2_skip.txt), $(PDBFINDERIDS))
DATFILES2.pdbfinder2            = $(PDBFINDER2IDS:%=$(DATADIR)pdbfinder2/data/%.dat)
DELETE.pdbfinder2                = $(filter-out $(PDBFINDERIDS:%=$(DATADIR)pdbfinder2/data/%.dat), $(wildcard $(DATADIR)pdbfinder2/data/*.dat))
WHY_NOT_DIR.pdbfinder2            = $(DATADIR)$(DATABANK)/PDBFIND2.TXT
WHY_NOT_DB.pdbfinder2            = PDBFINDER2
PATHS                            += $(DATADIR)/pdbfinder2/data/
MAKE_DATA_FLAGS.pdbfinder2        += -j32

pdbfinder2: pdbfinder pdbreport

$(DATADIR)pdbfinder2/data/%.dat: $(DATADIR)pdbfinder/data/%.dat 
	/srv/data/prog/pdbfinder2/what_modelbase.py -pdbftopdbf2 $(@F:%.dat=%) || ( echo $(@F:%.dat=%) >> $(STATSDIR)pdbfinder2_skip.txt )

$(DATADIR)pdbfinder2/PDBFIND2.TXT: $(DATFILES2.pdbfinder2)
	if [ "x$(DELETE.pdbfinder2)" != "x" ] ; then rm -f $(DELETE.pdbfinder2); fi
	/srv/data/prog/pdbfinder2/mergepdbfinder2.pl $@ $(DATADIR)pdbfinder2/data/
	gzip -c $@ > $@.gz

DATABANKS                        += pdbreport
PDBREPORTIDS                    = $(filter-out $(shell cat pdbreport_skip.txt), $(PDBIDS))
DATFILES.pdbreport              = $(foreach id,$(PDBREPORTIDS),$(DATADIR)pdbreport/$(call pdbdiv,$(id))/$(id)/index.html)
#DATFILES.pdbreport                = $(PDBIDS:%=$(DATADIR)pdbreport/%/index.html)
#DELETE.pdbreport                = $(filter-out $(DATFILES.pdbreport), $(wildcard $(DATADIR)pdbreport/flat/*))
OBSOLETE.pdbreport                = $(filter-out $(foreach id, $(PDBIDS),$(DATADIR)pdbreport/$(call pdbdiv,$(id))/$(id)), $(wildcard $(DATADIR)pdbreport/??/????))
#VPATH.pdbreport                    = %/index.html $(wildcard $(DATADIR)pdbreport/*)
WHY_NOT_DB.pdbreport            = PDBREPORT
MAKE_DATA_FLAGS.pdbreport        += -j32
#OBSOLETE.pdbreport                = $(shell find /srv/data/pdbreport/ -name 'index.html' | grep '/../..../' | cut -c-23) 
OBSOLETEDIR.pdbreport            = $(DATADIR)pdbreport/obsolete/

ifeq ($(DATABANK),pdbreport)
include pdbreport.depends
endif

pdbreport.depends:
	 find $(DATADIR)pdb/all/ -name "pdb*.ent.gz" | \
	    sed -e 's|$(DATADIR)pdb/all/pdb\(.\)\(..\)\(.\)\.ent\.gz|$(DATADIR)pdbreport/\2/\1\2\3/index.html: \0\n|' \
	    > pdbreport.depends

$(DATADIR)pdbreport/%/index.html:
	id=$(notdir $(@D)); $(BINDIR)wc.csh $$id || (echo $$id >> pdbreport_skip.txt)

#	id=`echo $(@D:$(DATADIR)pdbreport/%=%)|cut -c4-7`; grep -q $$id pdbreport_skip.txt || ($(BINDIR)wc.csh $$id || ( echo $$id >> pdbreport_skip.txt )
#$(DATADIR)pdbreport/%/index.html:
#	id=`echo $(@D:$(DATADIR)pdbreport/%=%)`; grep -q $$id pdbreport_skip.txt || ($(BINDIR)wc.csh $$id || ( echo $$id >> pdbreport_skip.txt ))

SF_FILES                        = $(wildcard $(DATADIR)structure_factors/r*sf.ent.gz)
SF_IDS                            = $(SF_FILES:$(DATADIR)structure_factors/r%sf.ent.gz=%)

pdb_redo: structure_factors

PDBREDOSKIP                    = $(BINDIR)pdbredo_skip.txt
DATABANKS                    += pdb_redo
# Only build the pdb_redo files that have never been created yet
PDB_REDO_IDS                    = $(shell snarf http://www.cmbi.ru.nl/WHY_NOT2/resources/list/PDB_REDO_UNANNOTATED -)
PDB_REDO_IDS                    := $(filter-out $(shell cat $(PDBREDOSKIP)), $(PDB_REDO_IDS))
DATFILES.pdb_redo                = $(PDB_REDO_IDS:%=$(DATADIR)pdb_redo/flags/%)
WHY_NOT_DB.pdb_redo                = PDB_REDO
MAKE_DATA_FLAGS.pdb_redo        = -j32
PDB_REDO_FLAG_DELETE            = $(filter-out $(SF_IDS:%=$(DATADIR)pdb_redo/flags/%), $(wildcard $(DATADIR)pdb_redo/flags/????))
PDB_REDO_DIR_DELETE                = $(filter-out $(foreach id, $(SF_IDS), $(DATADIR)pdb_redo/$(call pdbdiv,$(id))/$(id)/), $(dir $(wildcard $(DATADIR)pdb_redo/*/*/*_final.pdb)))
PDB_REDO.DELETE                 = $(PDB_REDO_FLAG_DELETE) $(PDB_REDO_DIR_DELETE)

#VPATH.pdb_redo                    = $(DATADIR)structure_factors

# pdb_redo explanation:
# - If a ????_final_tot.pdb is generated, make a symbolic link.
# - If an update runs longer than x days, don't start any new pdb_redo jobs
# - Each job may run for x days at most. If it times out, send a comment to /srv/data/zata/whynot.txt
# - Run each pdbid only once. After one failure, register it in pdbredo_skip.txt.
$(DATADIR)pdb_redo/flags/%: $(DATADIR)structure_factors/r%sf.ent.gz
	/usr/bin/timeout 3d /bin/bash -c '$(PDBREDOSCRIPT) $* && touch $@ || echo $* >> $(PDBREDOSKIP)' || \
	    (/bin/echo -e "COMMENT: PDB REDO script timed out\nPDB_REDO, $*" >> /srv/data/zata/whynot.txt; echo $* >> $(PDBREDOSKIP))
	p=`find $(DATADIR)pdb_redo/ -name $*_final_tot.pdb | head -n1`; \
	    if [ $$p ] ; then ln -s $$p $(DATADIR)pdb_redo/flat/$* ; fi

PRESENT_PDB_REDO_FILES            = $(wildcard $(DATADIR)pdb_redo/*/*/*_final.pdb)
PRESENT_PDB_REDO_IDS            = $(notdir $(PRESENT_PDB_REDO_FILES:%_final.pdb=%))

DATABANKS            += dssp_redo
#DSSP_REDO_IDS            := $(filter-out $(shell cat dssp_redo_skip.txt || echo ''), $(PRESENT_PDB_REDO_IDS))
DSSP_REDO_IDS            := $(PRESENT_PDB_REDO_IDS)
DATFILES.dssp_redo        = $(DSSP_REDO_IDS:%=$(DATADIR)dssp_redo/%.dssp)
DELETE.dssp_redo                = $(filter-out $(DATFILES.dssp_redo), $(wildcard $(DATADIR)dssp_redo/*.dssp))
WHY_NOT_DB.dssp_redo        = DSSP_REDO
WHY_NOT_DIR.dssp_redo        = $(DATADIR)dssp_redo

ifeq ($(DATABANK),dssp_redo)
include dssp_redo.depends
endif

dssp_redo.depends:
	find $(DATADIR)pdb_redo/??/????/ -name "????_final.pdb" | \
	    sed -e 's|$(DATADIR)pdb_redo/\(..\)/\(....\)/\(....\)_final\.pdb|$(DATADIR)dssp_redo/\3.dssp: \0\n|' \
	    > dssp_redo.depends

$(DATADIR)dssp_redo/%.dssp:
	($(MKDSSP) $(DATADIR)pdb_redo/$(call pdbdiv,$*)/$*/$*_final.pdb $(DATADIR)dssp_redo/$*.dssp 2> /srv/data/scratch/whynot2/dssp_redo/$*.err) || grep -q $* dssp_redo_skip.txt || ( echo $* >> dssp_redo_skip.txt; rm -f $@ )

MAKE_DATA_FLAGS.dssp_redo                    = -j32

dssp_redo: pdb_redo

DATABANKS                        += XML-noatom
#FLATTEN.XML-noatom                = XML-noatom
RSYNC_URL.XML-noatom            = rsync.wwpdb.org::ftp_data/structures/divided/XML-noatom/**/
RSYNC_OPTIONS.XML-noatom        = -rtv --delete --port=33444 --include='????-noatom.xml.gz' --exclude='*'
RSYNC_DEST.XML-noatom           = $(DATADIR)XML-noatom/
DELETE.XML-noatom                = $(FRAUDULENIDS:%=$(DATADIR)XML-noatom/%-noatom.xml.gz)

DATABANKS                        += uniprot
WGET_SOURCE.uniprot		= ftp://ftp.ebi.ac.uk/pub/databases/uniprot/current_release/knowledgebase/complete/
WGET_OPTIONS.uniprot            += --accept='uniprot_*.fasta.gz,README,reldate*,uniprot_*.dat.gz'
DATFILES.uniprot                = $(FASTADIR)uniprot_sprot.fasta $(FASTADIR)uniprot_trembl.fasta

include hb2.depends

hb2.depends:
	for file in `find $(DATADIR)pdb/flat/ -name 'pdb????.ent'`; do \
		pdbid=`basename $$file | grep -o '[0-9][0-9a-z]\{3\}'`; /bin/echo -e "$(DATADIR)wi-lists/pdb/hb2/$$pdbid/$$pdbid.hb2.bz2: $$file\n\t$(BINDIR)whatif-hbonds.bash $$< | bzip2 > $$@" >> $@; done

DATABANK += hb2_pdb
MAKE_DATA_FLAGS.hb2_pdb = -j32 -k
DATFILES.hb2_pdb = $(PDBIDS:%=$(DATADIR)wi-lists/pdb/hb2/%/%.hb2.bz2)

ifneq (,$(findstring wi_list_,$(DATABANK)))
INPUTTYPE                = $(word 3,$(subst _, ,$(DATABANK)))
LIS                         = $(lastword $(subst _, ,$(DATABANK)))
include $(DATABANK).depends
#WHY_NOT_DB.$(DATABANK)            = WHATIF_$(call uc,$(INPUTTYPE))_$(LIS)
#WHY_NOT_DIR.$(DATABANK)            = $(DATADIR)wi-lists/$(INPUTTYPE)/$(LIS)/
endif

ifneq (,$(findstring wi_scenes_,$(DATABANK)))
INPUTTYPE                               = $(word 3,$(subst _, ,$(DATABANK)))
LIS                                     = $(lastword $(subst _, ,$(DATABANK)))
include $(DATABANK).depends
#WHY_NOT_DB.$(DATABANK)                  = $(call uc,$(INPUTTYPE))_SCENES_$(LIS)
#WHY_NOT_DIR.$(DATABANK)                 = $(DATADIR)wi-lists/$(INPUTTYPE)/scenes/$(LIS)/
endif

LISTYPES = acc cal cc1 cc2 cc3 chi dsp iod sbh sbr ss1 ss2 tau wat
LISTYPES_SCENES = ss2 iod

include lis.dataflags

lis.dataflags:
	(for lis in $(LISTYPES) ; do \
	    echo MAKE_DATA_FLAGS.wi_list_pdb_$$lis = -j32; echo MAKE_DATA_FLAGS.wi_list_redo_$$lis = -j32; \
	done ; \
	for lis in $(LISTYPES_SCENES) ; do \
	    echo MAKE_DATA_FLAGS.wi_scenes_pdb_$$lis = -j32; echo MAKE_DATA_FLAGS.wi_scenes_redo_$$lis = -j32; \
	done) > lis.dataflags

include lis.whynots

lis.whynots:
	(for lis in $(LISTYPES) ; do \
	            echo WHY_NOT_DB.wi_list_pdb_$$lis = WHATIF_PDB_$$lis; echo WHY_NOT_DB.wi_list_redo_$$lis =  WHATIF_REDO_$$lis; \
	    echo WHY_NOT_DIR.wi_list_pdb_$$lis = $(DATADIR)wi-lists/pdb/$$lis/; echo WHY_NOT_DIR.wi_list_redo_$$lis = $(DATADIR)wi-lists/redo/$$lis/; \
	done ; \
	for lis in $(LISTYPES_SCENES) ; do \
	    echo WHY_NOT_DB.wi_scenes_pdb_$$lis = PDB_SCENES_$$lis; echo WHY_NOT_DB.wi_scenes_redo_$$lis = REDO_SCENES_$$lis; \
	    echo WHY_NOT_DIR.wi_scenes_pdb_$$lis = $(DATADIR)wi-lists/pdb/scenes/$$lis/; echo WHY_NOT_DIR.wi_scenes_redo_$$lis = $(DATADIR)wi-lists/redo/scenes/$$lis/; \
	done) > lis.whynots

DATABANKS += $(foreach lis, $(LISTYPES), wi_list_pdb_$(lis) wi_list_redo_$(lis))

WHYNOTFILES.wi_list_$(INPUTTYPE)_$(LIS) = $(wildcard $(DATADIR)wi-lists/$(INPUTTYPE)/$(LIS)/*/*.whynot)
UNAVAILABLE.wi_list_$(INPUTTYPE)_$(LIS) = $(WHYNOTFILES.wi_list_$(INPUTTYPE)_$(LIS):%.whynot=%.bz2)

DATFILES.wi_list_pdb_$(LIS)     = $(foreach id, $(PDBIDS), $(DATADIR)wi-lists/pdb/$(LIS)/$(id)/$(id).$(LIS).bz2)
DATFILES.wi_list_redo_$(LIS)    = $(foreach id, $(PRESENT_PDB_REDO_IDS), $(DATADIR)wi-lists/redo/$(LIS)/$(id)/$(id).$(LIS).bz2)

DELETE.wi_list_pdb_$(LIS)    = $(filter-out $(DATFILES.wi_list_pdb_$(LIS)), $(wildcard  $(DATADIR)wi-lists/pdb/$(LIS)/*/*.$(LIS).bz2))
DELETE.wi_list_redo_$(LIS)    = $(filter-out $(DATFILES.wi_list_redo_$(LIS)), $(wildcard $(DATADIR)wi-lists/redo/$(LIS)/*/*.$(LIS).bz2))
DELETE.wi_scenes_pdb_$(LIS)    = $(filter-out $(DATFILES.wi_scenes_pdb_$(LIS)), $(wildcard  $(DATADIR)wi-lists/pdb/scenes/$(LIS)/*/*.sce))
DELETE.wi_scenes_redo_$(LIS)    = $(filter-out $(DATFILES.wi_scenes_redo_$(LIS)),$(wildcard $(DATADIR)wi-lists/redo/scenes/$(LIS)/*/*.sce))

# This should speed up the update, it skips the entries that have whynot files.
# Remove the whynot files to rerun ..
DATFILES.wi_list_$(INPUTTYPE)_$(LIS) := $(filter-out $(UNAVAILABLE.wi_list_$(INPUTTYPE)_$(LIS)), $(DATFILES.wi_list_$(INPUTTYPE)_$(LIS)))
DELETE.wi_list_$(INPUTTYPE)_$(LIS)   := $(filter-out $(UNAVAILABLE.wi_list_$(INPUTTYPE)_$(LIS)), $(DELETE.wi_list_$(INPUTTYPE)_$(LIS)))

# scenes specific settings:
TITLE.ss2 = sym-contacts
TITLE.iod = ion-sites

WI_$(INPUTTYPE)_$(LIS)_PRESENT          = $(wildcard $(DATADIR)wi-lists/$(INPUTTYPE)/$(LIS)/*/*.$(LIS).bz2)
WI_$(INPUTTYPE)_$(LIS)_IDS              = $(notdir $(WI_$(INPUTTYPE)_$(LIS)_PRESENT:%.$(LIS).bz2=%))
DATFILES.wi_scenes_$(INPUTTYPE)_$(LIS)  = $(foreach id,$(WI_$(INPUTTYPE)_$(LIS)_IDS),$(DATADIR)wi-lists/$(INPUTTYPE)/scenes/$(LIS)/$(id)/$(id)_$(TITLE.$(LIS)).sce)

DATABANKS += $(foreach lis, $(LISTYPES_SCENES), wi_scenes_pdb_$(lis) wi_scenes_redo_$(lis))

wi_list_pdb_$(LIS).depends:
	find $(DATADIR)pdb/all/ -name "pdb????.ent.gz" | \
	    sed -e 's|$(DATADIR)pdb/all/pdb\(....\)\.ent\.gz|$(DATADIR)wi-lists/redo/$(LIS)/\1.$(LIS): \0\n|' \
	    > wi_list_pdb_$(LIS).depends

wi_list_redo_$(LIS).depends:
	find $(DATADIR)pdb_redo/??/????/ -name "????_final.pdb" | \
	    sed -e 's|$(DATADIR)pdb_redo/\(..\)/\(....\)/\(....\)_final\.pdb|$(DATADIR)wi-lists/redo/$(LIS)/\3.$(LIS): \0\n|' \
	    > wi_list_redo_$(LIS).depends

wi_scenes_$(INPUTTYPE)_$(LIS).depends:
	find $(DATADIR)wi-lists/$(INPUTTYPE)/$(LIS)/ -name "*.$(LIS).bz2" | \
	    sed -e 's|$(DATADIR)wi-lists/\(.\+\)/\(...\)/\(....\)/\(....\)\.$(LIS)\.bz2|$(DATADIR)wi-lists/\1/scenes/\2/\3/\4_$(TITLE.$(LIS)).sce: \0\n|' \
	    > wi_scenes_$(INPUTTYPE)_$(LIS).depends

$(DATADIR)wi-lists/%.bz2:
	$(BINDIR)whatif-list.bash $(wordlist 1,3,$(subst /, ,$*)) || echo failed: $@

$(DATADIR)wi-lists/$(INPUTTYPE)/scenes/$(LIS)/%.sce:
	$(BINDIR)scene.bash $(INPUTTYPE) $(LIS) $(firstword $(subst /, ,$*)) || echo failed: $@

$(FASTADIR)%.fasta: $(DATADIR)uniprot/%.fasta.gz
	zcat -c $< > $@.tmp && mv -f $@.tmp $@

# The generic rules

vpath $(VPATH.$(DATABANK))

$(FLAGSDIR)$(DATABANK).fetch_done:
	if [ "x$(RSYNC_URL.$(DATABANK))" != "x" ] ; then /usr/bin/timeout 12h /usr/bin/rsync $(RSYNC_EXCLUDES) $(RSYNC_OPTIONS.$(DATABANK)) $(RSYNC_URL.$(DATABANK)) $(RSYNC_DEST.$(DATABANK)); \
	elif [ "x$(WGET_SOURCE.$(DATABANK))" != "x" ] ; then /usr/bin/wget $(WGET_OPTIONS.$(DATABANK)) $(WGET_SOURCE.$(DATABANK)) -P $(WGET_DEST.$(DATABANK)); \
	fi
	touch $@

#	elif [ "x$(FLATTEN.$(DATABANK))" != "x" ] ; then $(PERL) flatten-and-clean-up.pl $(DATABANK);

fetch: $(FLAGSDIR)$(DATABANK).fetch_done

#$(DATABANK)$(DATABANK)flat/%: %.gz
#	$(GZCAT) $< > $@
#	touch -cr $< $@


# obsolete files must be copied with cp, because mv can throw errors if the file already exists
$(FLAGSDIR)$(DATABANK).data_done: $(DATFILES.$(DATABANK))
	if [ "x$(DELETE.$(DATABANK))" != "x" ] ; then rm -rf $(DELETE.$(DATABANK)); fi
	if [ "x$(OBSOLETE.$(DATABANK))" != "x" ] ; then cp -rf $(OBSOLETE.$(DATABANK)) $(OBSOLETEDIR.$(DATABANK)); rm -rf $(OBSOLETE.$(DATABANK)); fi
	$(RUNAFTER.$(DATABANK))
	touch $@

data: $(FLAGSDIR)$(DATABANK).data_done

#	    /usr/bin/java -cp $(WHYNOTDIR)dependency/*:$(WHYNOTDIR)whynot-apps.jar nl.ru.cmbi.whynot.crawl.Crawler \
#	    $(WHY_NOT_DB.$(DATABANK)) $(WHY_NOT_DIR.$(DATABANK)) || echo "nothing to crawl";
$(FLAGSDIR)$(DATABANK).crawl_done: FORCE
	if [ "$(WHY_NOT_DIR.$(DATABANK))x$(WHY_NOT_DB.$(DATABANK))" != "x" ] ; then \
	    $(WHYNOTDIR)crawl.py $(WHY_NOT_DB.$(DATABANK)) $(WHY_NOT_DIR.$(DATABANK)); \
	fi
	touch $@

crawl: $(FLAGSDIR)$(DATABANK).crawl_done

dirs: $(PATHS)

$(PATHS):
	mkdir -p $@

$(DATABANKS): dirs
	touch start_data_flag
	perl -i -nle 'print unless m/$@/' $(STATSDIR)failed_dbs.txt
	+ if [ "$(RSYNC_URL.$@)x$(WGET_SOURCE.$@)" != "x" ] ; then $(RUN_MAKE) -r 5 -l $(STATSDIR)$@.fetch_log $(MAKE) -rf $(BINDIR)update-databanks DATABANK=$@ fetch || (echo $@ >> $(STATSDIR)failed_dbs.txt ; /bin/false ) ; fi
	touch $(STATSDIR)$@.fetch_done
	+ $(RUN_MAKE) -r 5 -l $(STATSDIR)$@.data_log time $(MAKE) -rf $(BINDIR)update-databanks $(MAKE_DATA_FLAGS.$@) DATABANK=$@ data || (echo $@ >> $(STATSDIR)failed_dbs.txt ; /bin/false )
	touch $(STATSDIR)$@.data_done
	+ if [ "$(WHY_NOT_DB.$@)x" != "x" ] ; then $(RUN_MAKE) -r 5 -l $(STATSDIR)$@.crawl_log $(MAKE) -rf $(BINDIR)update-databanks DATABANK=$@ crawl ; fi
	touch $(STATSDIR)$@.crawl_done

clean:
	rm -rf $(FLAGSDIR)*
	rm -f *.depends lis.*s

all: $(DATABANKS)
	rm -rf $(FLAGSDIR)*
	rm -f *.depends lis.*s
	/srv/data/pdb_redo/alldata.csh
	$(WHYNOTDIR)annotate.py
#	$(WHYNOTDIR)run_scripts.sh
#	$(WHYNOTDIR)run_annotater.sh

FORCE: ;

echo-whynot:
	echo $(WHY_NOT_DB.$(DATABANK)) $(WHY_NOT_DIR.$(DATABANK))

echo-pdb-redo-ids:
	echo $(PDB_REDO_IDS)

echo-pdbids:
	echo $(PDBIDS)

echo-datfiles:
	echo $(DATFILES.$(DATABANK))

echo-obsolete:
	echo $(OBSOLETE.$(DATABANK))

echo-delete:
	echo $(DELETE.$(DATABANK))

echo-outdated:
	echo hssp: $(OUTDATED_HSSP3)

wi-listfiles:
	echo $(wildcard $(DATADIR)wi-lists/pdb/$(LIS)/*/*.$(LIS).bz2)
